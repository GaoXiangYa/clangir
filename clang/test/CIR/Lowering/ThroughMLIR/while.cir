// RUN: cir-opt %s -cir-to-mlir -o %t.mlir
// RUN: FileCheck %s --input-file %t.mlir

!s32i = !cir.int<s, 32>
module {
  cir.func @foo() {
    %0 = cir.alloca !s32i, !cir.ptr<!s32i>, ["__retval"] {alignment = 4 : i64}
    %1 = cir.alloca !s32i, !cir.ptr<!s32i>, ["a", init] {alignment = 4 : i64}
    %2 = cir.const #cir.int<0> : !s32i
    cir.store %2, %1 : !s32i, !cir.ptr<!s32i>
    cir.while {
      %3 = cir.load %1 : !cir.ptr<!s32i>, !s32i
      %4 = cir.const #cir.int<2> : !s32i
      %5 = cir.cmp(lt, %3, %4) : !s32i, !cir.bool
      cir.condition(%5)
    } do {
      %3 = cir.load %1 : !cir.ptr<!s32i>, !s32i
      %4 = cir.unary(inc, %3) : !s32i, !s32i
      cir.store %4, %1 : !s32i, !cir.ptr<!s32i>
      cir.yield
    }
    cir.return
  }
}

//CHECK: module {
//CHECK-NEXT:  func.func @foo() {
//CHECK-NEXT:    %alloca = memref.alloca() {alignment = 4 : i64} : memref<i32>
//CHECK-NEXT:    %alloca_0 = memref.alloca() {alignment = 4 : i64} : memref<i32>
//CHECK-NEXT:    %c0_i32 = arith.constant 0 : i32
//CHECK-NEXT:    memref.store %c0_i32, %alloca_0[] : memref<i32>
//CHECK-NEXT:    scf.while : () -> () {
//CHECK-NEXT:      %0 = memref.load %alloca_0[] : memref<i32>
//CHECK-NEXT:      %c2_i32 = arith.constant 2 : i32
//CHECK-NEXT:      %1 = arith.cmpi ult, %0, %c2_i32 : i32
//CHECK-NEXT:      %2 = arith.extui %1 : i1 to i8
//CHECK-NEXT:      %3 = arith.trunci %2 : i8 to i1
//CHECK-NEXT:      scf.condition(%3)
//CHECK-NEXT:    } do {
//CHECK-NEXT:      %0 = memref.load %alloca_0[] : memref<i32>
//CHECK-NEXT:      %c1_i32 = arith.constant 1 : i32
//CHECK-NEXT:      %1 = arith.addi %0, %c1_i32 : i32
//CHECK-NEXT:      memref.store %1, %alloca_0[] : memref<i32>
//CHECK-NEXT:      scf.yield
//CHECK-NEXT:    }
//CHECK-NEXT:    return
//CHECK-NEXT:  }
//CHECK-NEXT:}